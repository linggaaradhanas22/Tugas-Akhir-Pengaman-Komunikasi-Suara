
---------------------------------------------------------
--  This code is generated by Terasic System Builder
---------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity WM8731_ver3 is
port
(

	------------ CLOCK ------------
	CLOCK2_50       	:in    	std_logic;
	CLOCK3_50       	:in    	std_logic;
	CLOCK4_50       	:in    	std_logic;
	CLOCK_50        	:in    	std_logic;

	------------ KEY ------------
	KEY             	:in    	std_logic_vector(3 downto 0);

	------------ SW ------------
	SW              	:in    	std_logic_vector(9 downto 0);

	------------ LED ------------
	LEDR            	:out   	std_logic_vector(9 downto 0);

	------------ Audio ------------
	AUD_ADCDAT      	:in    	std_logic;
	AUD_ADCLRCK     	:inout 	std_logic;
	AUD_BCLK        	:inout 	std_logic;
	AUD_DACDAT      	:out   	std_logic;
	AUD_DACLRCK     	:inout 	std_logic;
	AUD_XCK         	:buffer   	std_logic;

	------------ I2C for Audio and Video-In ------------
	FPGA_I2C_SCLK   	:out   	std_logic;
	FPGA_I2C_SDAT   	:inout 	std_logic
);

end entity;



---------------------------------------------------------
--  Structural coding
---------------------------------------------------------


architecture rtl of WM8731_ver3 is

	-- declare --
--	signal Top : unsigned(11 downto 0);
--	signal L_wr, R_wr, 
	signal Ldone, Rdone : std_logic;
	signal Lin, Rin, Lout, Rout : signed(15 downto 0);

--	signal ML, MR : std_logic_vector(15 downto 0);
--	signal L_echo, R_echo : signed(15 downto 0);
	
--	type sstate is (s1, s2, s3, s4, s5, s6, s7);
--	signal RCV : sstate;


begin

	-- body --
  Audio_interface: entity work.Audio_interface
  Generic map (SAMPLE_RATE => 32 --in KHz
					)
  Port map (
		clk => clock_50,
		rst => not key(0),
		AUD_XCK => AUD_XCK,
		I2C_SCLK => FPGA_I2C_SCLK,
      I2C_SDAT => FPGA_I2C_SDAT,
		AUD_BCLK => AUD_BCLK,
		AUD_DACLRCK => AUD_DACLRCK,
		AUD_ADCLRCK => AUD_ADCLRCK,
		AUD_ADCDAT => AUD_ADCDAT,
		AUD_DACDAT => AUD_DACDAT,
		Rin => Rin,
		Lin => Lin,
		Rout => Rout,
		Lout => Lout,
		Rdone => Rdone,
		Ldone => Ldone
		);
--	--------------------------------------------------------------
--	-- For Audio Echo effect Audio Memories: 4K x 16 x 2 channels
--	--------------------------------------------------------------
--	Audio_memory_Left : entity work.aram port map(
--		clock	=> AUD_XCK,
--		data => std_logic_vector(Lin),
--		wraddress => std_logic_vector(TOP),
--		wren => L_wr,
--		rdaddress => std_logic_vector(TOP + 1),	
--		q => ML
--	);
--	Audio_memory_Right : entity work.aram port map(
--		clock	=> AUD_XCK,
--		data => std_logic_vector(Rin),
--		wraddress => std_logic_vector(TOP),
--		wren => R_wr,
--		rdaddress => std_logic_vector(TOP + 1),	
--		q => MR
--	);
	
	-- Pass trough audio directly
	Lout <= Lin; 
	Rout <= Rin; 
	
	
	--------------------------------------------------------------
	--	LEDR(0) <= SW(0);
	-------------------------------------------------------------
	-- SW(0)=0 send out Lin/Rin (bypass)
	-- SW(0)=1 send out L_echo/R_echo (echo)
	--------------------------------------------------------------
--	Audio_Mem_control: process(AUD_XCK, key(0))
--	begin
--		if(key(0) = '0') then			
--			TOP <= "000000000000";
--			L_echo <= x"0000";
--			R_echo <= x"0000";
--			L_wr <= '0';
--			R_wr <= '0';
--			RCV <= s1;	
--		elsif(AUD_XCK'event AND AUD_XCK = '1') then
--			case RCV is
--				when s1 =>	
--					R_wr <= '0';
--					if(Ldone='1') then RCV <= s2; end if;
--				when s2 =>	
--					L_echo <= Lin/2 + signed(ML)/2;
--					RCV <= s3;
--				when s3 =>
--					L_wr <= '1';
--					if(SW(0)='0') then 
--						Lout <= Lin; 
--					else 
--						Lout <= L_echo; 
--					end if; 
--					RCV <= s4;
--				when s4 =>	
--					L_wr <= '0';
--					if(Rdone='1') then RCV <= s5; end if;
--				when s5 =>	
--					R_echo <= Rin/2 + signed(MR)/2;
--					RCV <= s6;
--				when s6 =>
--					R_wr <= '1';
--					if(SW(0)='0') then 
--						Rout <= Rin; 
--					else 
--						Rout <= R_echo; 
--					end if; 
--					RCV <= s7;	
--				when s7 =>
--					R_wr <= '0';
--					TOP <= TOP + 1; 
--					RCV <= s1;
--				when others =>
--					RCV <= s1;
--			end case;
--		end if;		
--	end process;

end rtl;

