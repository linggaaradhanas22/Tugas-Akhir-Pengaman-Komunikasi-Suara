
---------------------------------------------------------
--  This code is generated by Terasic System Builder
---------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Scrambler_Receiver is
port
(

	------------ CLOCK ------------
	CLOCK2_50       	:in    	std_logic;
	CLOCK3_50       	:in    	std_logic;
	CLOCK4_50       	:in    	std_logic;
	CLOCK_50        	:in    	std_logic;

	------------ KEY ------------
	KEY             	:in    	std_logic_vector(3 downto 0);

	------------ SW ------------
	SW              	:in    	std_logic_vector(9 downto 0);

	------------ LED ------------
	LEDR            	:out   	std_logic_vector(9 downto 0);

	------------ Audio ------------
	AUD_ADCDAT      	:in    	std_logic;
	AUD_ADCLRCK     	:inout 	std_logic;
	AUD_BCLK        	:inout 	std_logic;
	AUD_DACDAT      	:out   	std_logic;
	AUD_DACLRCK     	:inout 	std_logic;
	AUD_XCK         	:buffer   	std_logic;

	------------ I2C for Audio and Video-In ------------
	FPGA_I2C_SCLK   	:out   	std_logic;
	FPGA_I2C_SDAT   	:inout 	std_logic
);

end entity;



---------------------------------------------------------
--  Structural coding
---------------------------------------------------------


architecture rtl of Scrambler_Receiver is

-- declare --
	-- For interfacing with the Audio Interface design
	signal Lin, Rin, Lout, Rout : signed(15 downto 0);
	signal Ldone, Rdone : std_logic;
	
	-- For interfacing with the scrambler
	signal in_real, out_real : std_logic_vector(15 downto 0);
	signal do_en 	  : std_logic;
	signal shift_key  : std_logic_vector(23 downto 0);
	
	-- For interfacing with correlator
	signal out_valid : std_logic;
	signal Aud_interface_ready : std_logic := '1';
	signal enable : std_logic := '0';
	signal dataA : std_logic_vector(15 downto 0);

	
	-- Scrambler Component declaration (Verilog entity)
	component ScramblerAudio
	port (
		clock  	  : in std_logic;
		reset     : in std_logic;
		di_en 	  :	in std_logic;
		shift_key : in std_logic_vector(23 downto 0);
		in_real	  : in std_logic_vector(15 downto 0);
		do_en	  : out std_logic;
		out_real  : out std_logic_vector(15 downto 0)
	);
	end component ScramblerAudio;

begin

-- body --

	LEDR(0) <= enable;
	LEDR(1) <= SW(0);
	shift_key <= "101001100010100110000000" when SW(0) = '1' else (others => '0');
	
	dataA <= std_logic_vector(Lin) when enable = '0' else (others => '0');
	in_real <= std_logic_vector(Lin) when enable = '1' and Ldone = '1' else (others => '0');
	
	-- For outputting the data
	Lout <= signed(out_real) when do_en = '1'   	else 
			(others => '0');
	
	-- Audio interface core instantiation
	Audio_interface: entity work.Audio_interface
	generic map (
		SAMPLE_RATE => 32 --in KHz
	)
	port map (
		clk => clock_50,
		rst => not key(0),
		AUD_XCK => AUD_XCK,
		I2C_SCLK => FPGA_I2C_SCLK,
		I2C_SDAT => FPGA_I2C_SDAT,
		AUD_BCLK => AUD_BCLK,
		AUD_DACLRCK => AUD_DACLRCK,
		AUD_ADCLRCK => AUD_ADCLRCK,
		AUD_ADCDAT => AUD_ADCDAT,
		AUD_DACDAT => AUD_DACDAT,
		Lin => Lin,
		Ldone => Ldone,
		Rout => Rout,
		Lout => Lout
	);

	
	-- Scrambler instance
	Scrambler_interface: ScramblerAudio
	port map (
		clock => AUD_XCK,
		reset => not KEY(0),
		di_en => enable,
		do_en => do_en,
		shift_key => shift_key,
		in_real => in_real,
		out_real => out_real
	);
	
	DTMF_corr: entity work.toplevel_iq
	generic map (
		mult_INT_BITS   => 2,
		mult_FRAC_BITS  => 14,
		acc_INT_BITS    => 6,
		acc_FRAC_BITS   => 10,
		power_INT_BITS  => 10,
		power_FRAC_BITS => 6,
		batch_INT_BITS  => 14,
		batch_FRAC_BITS => 2
	)
	port map (
		clk		  => AUD_XCK,
		reset 	  => not KEY(0),
		in_valid  => Ldone, 
		out_ready => '1',
		-- Output port 
		in_ready  => Aud_interface_ready,
		out_valid => out_valid,
		-- Data interfacing
		dataA  	  => dataA,
		enable    => enable
	);

end rtl;

